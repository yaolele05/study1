//结合 OS 课程，从 “对象 vs 物理内存”
/*
操作系统只认识“内存页 / 字节”
C++ 才引入了“对象、构造、析构”这一层抽象
在 OS 眼里：
内存 = 一堆 物理页（page）
每个进程看到的是 虚拟地址空间
OS 负责：
1页表映射2回收页3进程结束时统一清理
OS视角：
地址 0x1000 ～ 0x2000：已分配
地址 0x2000 ～ 0x3000：空闲
*/
delete p;
//C++视角
p->~T();               // C++ 对象层
operator delete(p);    // 内存管理层 → 最终到 OS
//C++ 负责调用析构函数，释放对象占用的资源
//OS 负责回收内存页
//new/delete 只负责“分配/释放内存”，不负责“构造/析构对象”
//new T() = operator new + T::T()
//delete p = p->~T() + operator delete
//STL 容器的内存管理
//析构函数释放 p 指向的那块内存清理对象“内部资源”
//OS 还认为那块地址是“已分配”，因为 OS 只看得到那次 new / delete
//析构时为什么不能一步到位？因为：
//1.OS 只管“这块内存能不能回收”2.C++ 必须先保证：所有对象逻辑上“结束生命”资源不泄漏
/*
A* p = new A;
operator delete(p); // ❌
OS 角度：
内存释放了 
C++ 角度：
析构函数没执行 ❌
p 里的资源泄漏
文件 / 锁 / 内存全炸
*/
//内存还被占着 =内存泄漏（但不是对象泄漏）
//RAII 是 C++ 管理资源的核心原则：
/*
资源可以是：
内存，文件句柄，锁，套接字 / 线程 / GPU 资源
RAII 对象：
构造时获得资源
析构时释放资源
*/